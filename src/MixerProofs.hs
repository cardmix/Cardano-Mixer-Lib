{-# LANGUAGE DataKinds                  #-}
{-# LANGUAGE DeriveAnyClass             #-}
{-# LANGUAGE DeriveGeneric              #-}
{-# LANGUAGE DerivingStrategies         #-}
{-# LANGUAGE FlexibleContexts           #-}
{-# LANGUAGE FlexibleInstances          #-}
{-# LANGUAGE GeneralizedNewtypeDeriving #-}
{-# LANGUAGE MultiParamTypeClasses      #-}
{-# LANGUAGE NoImplicitPrelude          #-}
{-# LANGUAGE NumericUnderscores         #-}
{-# LANGUAGE OverloadedStrings          #-}
{-# LANGUAGE ScopedTypeVariables        #-}
{-# LANGUAGE TemplateHaskell            #-}
{-# LANGUAGE TypeApplications           #-}
{-# LANGUAGE TypeFamilies               #-}
{-# LANGUAGE TypeOperators              #-}
{-# LANGUAGE TypeSynonymInstances       #-}

module MixerProofs (generateWithdrawProof, generateSimulatedWithdrawProof, verifyWithdraw) where

import           Data.Aeson                       (decode)
import           Data.ByteString.Lazy             (readFile)
import           Data.Map                         (fromList)
import           PlutusTx.Prelude                 hiding (Semigroup(..), (<$>), unless, mapMaybe, find, toList, fromInteger)
import           Prelude                          (IO, (<$>))

import           Configuration.QAPConfig          (fileWithdrawR1CS, fileCRS)
import           Crypto
import           MixerState                       
import           MixerUserData
import           Utils.Common                     (replicate, last, init)


------------------------------------ Withdraw Proof ---------------------------------------------------

-- TODO: use data types here
generateWithdrawProof :: Fr -> DepositSecret -> ShieldedAccountSecret -> MixerState -> IO ((Integer, Integer), [Fr], Proof)
generateWithdrawProof pkh ds sas state = do
    (r1cs, wires) <- loadR1CSFile fileWithdrawR1CS
    crs <- fromMaybe emptyCRS . decode <$> readFile fileCRS
    let sa = SetupArguments r1cs wires
        (lastDeposit, _, insPub, insPriv) = computeWithdrawWires pkh ds sas state
    -- constructing witness
    let w  = fromList $ zip ((0 :: Integer) : [6..37])
            ([one] ++ insPub ++ insPriv)
        sol = solveR1CS r1cs w
        pa = ProveArguments sa crs sol
    proof <- generateProof pa
    return (lastDeposit, insPub, proof)

generateSimulatedWithdrawProof :: Fr -> DepositSecret -> ShieldedAccountSecret -> MixerState -> IO ((Integer, Integer), [Fr], Proof)
generateSimulatedWithdrawProof pkh ds sas state = do
    let (lastDeposit, outs, insPub, _) = computeWithdrawWires pkh ds sas state
        subs = [one] ++ outs ++ insPub
    secret <- generateProofSecret
    let proof = simulate withdrawSecret secret withdrawCRS subs
    return (lastDeposit, insPub, proof)

{-# INLINABLE verifyWithdraw #-}
verifyWithdraw :: [Fr] -> Proof -> Bool
verifyWithdraw = verify withdrawCRS

computeWithdrawWires :: Fr -> DepositSecret -> ShieldedAccountSecret -> MixerState -> ((Integer, Integer), [Fr], [Fr], [Fr])
computeWithdrawWires pkh (DepositSecret r1 r2) (ShieldedAccountSecret v1 v2 v3) state = ((k, m), publicOutputWires, publicInputWires, privateInputWires)
    where
        a                              = pkh
        leaf                           = mimcHash r1 r2
        k                              = fst $ fromMaybe (0, 0) $ getMerkleLeafNumber state leaf
        MerkleTree m leafs             = state !! k
        key                            = mimcHash zero r1
        keyA                           = mimcHash a r2
        oh                             = mimcHash v1 v2
        nh                             = mimcHash v1 v3
        coPath                         = getMerkleCoPath leafs m
        l                              = replicate treeSize zero
        root                           = last coPath

        publicOutputWires = replicate 5 zero
        publicInputWires  = [root, a, key, keyA, toZp m, oh, nh]
        privateInputWires = [r1, r2] ++ init coPath ++ l ++ [v1, v2, v3]

------------------------------ Withdraw Problem Definition --------------------------------------------

{-# INLINABLE withdrawCRS #-}
withdrawCRS :: ReducedReferenceString
withdrawCRS = ReducedReferenceString
    {
refRedGa = 
CP (Zp 3778909173505208597033181318607431847232574918681168608937206115163718887560125118174119709033881667205779792371747) (Zp 297477589671569558242163373814153938138055303558667195574775828063132096244332577103901713833625979208384455999546),
refRedHb = 
CP (E (P [Zp 3363433232793185152098120484268475918252318405456681395521773573050903780888456301927645104247675963923725865597431,Zp 2470675658607679051319172340244362831936548885307178616121294330075552058837509915040906340950389416835504469880312])) (E (P [Zp 1405909015419064165272896059602745526245188496580627755979678804317693442616194783359710516592090610000580544982061,Zp 2838246195005323122001025049624751619485284415015169181237069425099882180160208951759811427741721614294804778214189])),
refRedHg = 
CP (E (P [Zp 3182780997985820993544867945796761812452292754020414054801114169246729358230543061256774758308757611214579568866767,Zp 2662563630694481018672957728424829865110735451032128982625727173259090114941846796979732776245311271370040224651056])) (E (P [Zp 1472198638288980513188790823259541096870360478832406893519572647822354665065118586506057900937668885842839193550839,Zp 3880664888187646686506959770584108822048883440523154809496136852418154884969433140385601257659819019259196820112748])),
refRedHd = 
CP (E (P [Zp 2744272527895005698616029573324257244083388728663981162425707363697596793131018680228061622940836878443068066170524,Zp 1123810905600324444323122493249252830705250224507467667969191417999981616339450229567530092819463873250677242298795])) (E (P [Zp 2334086713642829838790121877854466812461541624761095819503502118298783435851390614419528188824135659001288278560909,Zp 1297473243691689419646350111606546835674408515751193655876438267978045317742711576352397626930141328617644647047637])),
refRedGpub = [
CP (Zp 3046491883462667763450272495811408254800836046779386843504715844950115525207823962398164391183534254947461179612660) (Zp 615849257576424159981352911774066075454605671726256830261348999316129376754824116375288089146817898707287163356019),
CP (Zp 3490557589353586505159394876157120131317310003419970058042289064274219674018957748927987187475773325810263399237151) (Zp 3944991525871478524477403834296910994350155639131097663332726914598092171449604793627755811126835674032840322451704),
CP (Zp 1591945118827759237114352893037524581932543933725410618544849947531524121845397467167382786855123381557607185844093) (Zp 2293869099542152656737335814242607467639547845016586464824794176109912311896760240739375606831196654242177478912539),
CP (Zp 1763891490628973194726760082051042032930011786201138885973226983416963688312676835732490781143108786067181560325397) (Zp 1463024903715905100375649726990802338277809231564189975420254620418358946990114578850452886331672460446110598848365),
CP (Zp 2862344775742817687233534948744477368828269650254358595307232065593967521592586985138235743955165761557971080745599) (Zp 2820149628585799876491821176025568044057588420131367533801747420688653223663867071706535130542084980214246333759493),
CP (Zp 3748966733947060468672915153170920270497682660621664700117235436913452242197504441662362164566431024752251995813033) (Zp 3133724104088372950556181810385891831002050293591564801420731821943928158384985786784906535832326446394290019679382),
CP (Zp 1763891490628973194726760082051042032930011786201138885973226983416963688312676835732490781143108786067181560325397) (Zp 1463024903715905100375649726990802338277809231564189975420254620418358946990114578850452886331672460446110598848365),
CP (Zp 432543065289023436523936922931567493907666187474374089241300931356809193823914901930457362164047632633855538488540) (Zp 721144067364155833395772622200507425934191911531665514628287767739630683996833393412204200779159929223007465248689),
CP (Zp 3490557589353586505159394876157120131317310003419970058042289064274219674018957748927987187475773325810263399237151) (Zp 3944991525871478524477403834296910994350155639131097663332726914598092171449604793627755811126835674032840322451704),
CP (Zp 1591945118827759237114352893037524581932543933725410618544849947531524121845397467167382786855123381557607185844093) (Zp 2293869099542152656737335814242607467639547845016586464824794176109912311896760240739375606831196654242177478912539),
CP (Zp 2381353271767700959755161642004851478318015457992721561569995623596442087808953034603279303432457818221853716992600) (Zp 306758529840478860533053775266799185375324941545981729390580700930731004531906555248276967023825873222682902590229),
CP (Zp 2862344775742817687233534948744477368828269650254358595307232065593967521592586985138235743955165761557971080745599) (Zp 2820149628585799876491821176025568044057588420131367533801747420688653223663867071706535130542084980214246333759493),
CP (Zp 3748966733947060468672915153170920270497682660621664700117235436913452242197504441662362164566431024752251995813033) (Zp 3133724104088372950556181810385891831002050293591564801420731821943928158384985786784906535832326446394290019679382)
]
    }
    
withdrawSecret :: ZKSetupSecret
withdrawSecret = ZKSetupSecret
  {
    secretAlpha = Zp 31166319297144590835384498065326183885678969878576160684492776349571265369561,
    secretBeta  = Zp 22217971736162304410974286655175391311938300667854221456573795939742078018842,
    secretGamma = Zp 24231911266267795336766923032129536952739002865218585400658043457508491429146,
    secretDelta = Zp 23922179100645229395296072467022171660941001855324254442556550539532739473801,
    secretX     = Zp 34962842270303863939238049877882078985638713473987714022146679502607935256580
  }